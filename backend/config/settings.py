"""
Django settings for config project.

Generated by 'django-admin startproject' using Django 5.2.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""

from pathlib import Path
import os
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = "django-insecure-k14j23-+4o*h)26ms8k#ghmv*kglz!hsf^h%sac1^sy7w6f2qw"

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True  # Force DEBUG mode to be permissive

ALLOWED_HOSTS = ['*']  # Allow all hosts


# Application definition

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",

    # Third-party apps
    "rest_framework",
    "rest_framework.authtoken",
    "corsheaders",

    # Local apps
    "users",
    "reports",
    "analytics",
    "data_collector",
    "query_builder",
    "instagram_data",
    "facebook_data",
    "track_accounts",
    "linkedin_data",
    "tiktok_data",
    "brightdata_integration",
    "chat",
    "workflow",
]

MIDDLEWARE = [
    "users.middleware.CustomCsrfMiddleware",  # ðŸš¨ CSRF BYPASS FIRST - OVERRIDES EVERYTHING
    "corsheaders.middleware.CorsMiddleware",  # CORS second
    "django.middleware.security.SecurityMiddleware",
    # "whitenoise.middleware.WhiteNoiseMiddleware",  # Temporarily disable whitenoise
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    # "django.middleware.csrf.CsrfViewMiddleware",  # NEVER ENABLE - COMPLETELY DISABLED
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    # "django.middleware.clickjacking.XFrameOptionsMiddleware",  # Disable X-Frame protection
]

ROOT_URLCONF = "config.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "config.wsgi.application"


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

# Default to SQLite for development
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "db.sqlite3",
    }
}

# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = "en-us"

TIME_ZONE = "UTC"

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = "/static/"
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')

# Disable WhiteNoise configuration temporarily
# STATICFILES_STORAGE = "whitenoise.storage.CompressedManifestStaticFilesStorage"

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

# Email Configuration
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = os.getenv('EMAIL_HOST', 'smtp.gmail.com')
EMAIL_PORT = int(os.getenv('EMAIL_PORT', 587))
EMAIL_USE_TLS = os.getenv('EMAIL_USE_TLS', 'True').lower() == 'true'
EMAIL_HOST_USER = os.getenv('EMAIL_HOST_USER', '')
EMAIL_HOST_PASSWORD = os.getenv('EMAIL_HOST_PASSWORD', '')
DEFAULT_FROM_EMAIL = os.getenv('DEFAULT_FROM_EMAIL', EMAIL_HOST_USER)

# For development, you can use console backend to see emails in console
# Uncomment the line below to use console backend for development
# if DEBUG:
#     EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'

# Completely disable custom logging to prevent file handler errors
# Use Django defaults only for deployment compatibility
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
        },
    },
    'root': {
        'handlers': ['console'],
    },
}

# Django REST Framework settings
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.TokenAuthentication',
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.BasicAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.AllowAny',
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10,
    'DEFAULT_RENDERER_CLASSES': [
        'rest_framework.renderers.JSONRenderer',
        'rest_framework.renderers.BrowsableAPIRenderer',
    ],
    'DEFAULT_PARSER_CLASSES': [
        'rest_framework.parsers.JSONParser',
        'rest_framework.parsers.FormParser',
        'rest_framework.parsers.MultiPartParser',
    ],
    'EXCEPTION_HANDLER': 'rest_framework.views.exception_handler',
    'UNAUTHENTICATED_USER': 'django.contrib.auth.models.AnonymousUser',
    'UNAUTHENTICATED_TOKEN': None,
}

# ðŸš¨ MAXIMUM PERMISSIVE CORS - ALLOW ABSOLUTELY EVERYTHING ðŸš¨
CORS_ALLOW_ALL_ORIGINS = True
CORS_ALLOW_CREDENTIALS = True
CORS_ALLOW_ALL_HEADERS = True
# CORS_REPLACE_HTTPS_REFERER is deprecated and removed

# Specifically allow your Upsun domain and any variations
CORS_ALLOWED_ORIGINS = [
    "https://api.upsun-deployment-xiwfmii-inhoolfrqniuu.eu-5.platformsh.site",
    "https://upsun-deployment-xiwfmii-inhoolfrqniuu.eu-5.platformsh.site",
    "http://localhost:3000",
    "http://localhost:5173",
    "http://localhost:8000",
]
CORS_ALLOWED_HEADERS = [
    'accept',
    'accept-encoding',
    'authorization',
    'content-type',
    'dnt',
    'origin',
    'user-agent',
    'x-csrftoken',
    'x-requested-with',
    'access-control-allow-origin',
    'access-control-allow-credentials',
    'access-control-allow-headers',
    'access-control-allow-methods',
]
CORS_ALLOW_METHODS = [
    'DELETE',
    'GET',
    'OPTIONS',
    'PATCH',
    'POST',
    'PUT',
]
CORS_PREFLIGHT_MAX_AGE = 86400
CORS_EXPOSE_HEADERS = []
CORS_ALLOW_PRIVATE_NETWORK = True

# ðŸš¨ COMPLETE CSRF BYPASS - NO ORIGIN CHECKING ðŸš¨
CSRF_COOKIE_SECURE = False
CSRF_COOKIE_HTTPONLY = False
CSRF_COOKIE_SAMESITE = None
CSRF_USE_SESSIONS = False

# ðŸš¨ NUCLEAR CSRF DISABLE - OVERRIDE DJANGO CORE ðŸš¨

# Completely disable CSRF at Django's core level
CSRF_COOKIE_SECURE = False
CSRF_COOKIE_HTTPONLY = False
CSRF_COOKIE_SAMESITE = None
CSRF_USE_SESSIONS = False

# Override Django's CSRF settings to bypass everything
import django.middleware.csrf
# Monkey patch Django's CSRF middleware to do nothing
original_process_view = django.middleware.csrf.CsrfViewMiddleware.process_view
def dummy_process_view(self, request, callback, callback_args, callback_kwargs):
    """Dummy CSRF process_view that does nothing"""
    return None
django.middleware.csrf.CsrfViewMiddleware.process_view = dummy_process_view

# Trust all origins (Django 4.0+ requires scheme prefixes)
CSRF_TRUSTED_ORIGINS = [
    # Upsun deployment URLs
    "https://api.upsun-deployment-xiwfmii-inhoolfrqniuu.eu-5.platformsh.site",
    "https://upsun-deployment-xiwfmii-inhoolfrqniuu.eu-5.platformsh.site",
    # Local development URLs
    "http://localhost:3000",
    "http://localhost:5173",
    "http://localhost:8000",
    "https://localhost:3000",
    "https://localhost:5173",
    "https://localhost:8000",
    # Common localhost variants
    "http://127.0.0.1:3000",
    "http://127.0.0.1:5173",
    "http://127.0.0.1:8000",
    "https://127.0.0.1:3000",
    "https://127.0.0.1:5173",
    "https://127.0.0.1:8000",
]

# Never fail CSRF
def never_fail_csrf(request, reason=""):
    """Custom CSRF failure view that never fails"""
    return None

CSRF_FAILURE_VIEW = never_fail_csrf

# Add dynamic origins for Upsun
DYNAMIC_CORS_ORIGINS = []
if os.getenv('PLATFORM_APPLICATION_NAME'):
    # Add all possible Upsun/Platform.sh patterns
    app_name = os.getenv('PLATFORM_APPLICATION_NAME', 'app')
    project_id = os.getenv('PLATFORM_PROJECT', '')
    environment = os.getenv('PLATFORM_ENVIRONMENT', 'main')

    if project_id:
        # All possible domain patterns
        base_patterns = [
            f"https://{app_name}-{project_id}.{environment}.platformsh.site",
            f"https://api.{app_name}-{project_id}.{environment}.platformsh.site",
            f"https://{app_name}-{project_id}.{environment}.upsun.app",
            f"https://api.{app_name}-{project_id}.{environment}.upsun.app",
            f"https://{project_id}.{environment}.platformsh.site",
            f"https://{project_id}.{environment}.upsun.app",
        ]
        DYNAMIC_CORS_ORIGINS.extend(base_patterns)
        CSRF_TRUSTED_ORIGINS.extend(base_patterns)

    # Also get from Platform routes if available
    platform_routes = os.getenv('PLATFORM_ROUTES')
    if platform_routes:
        try:
            import json
            routes = json.loads(platform_routes)
            for route_url in routes.keys():
                if route_url.startswith(('http://', 'https://')):
                    clean_url = route_url.rstrip('/')
                    DYNAMIC_CORS_ORIGINS.append(clean_url)
                    CSRF_TRUSTED_ORIGINS.append(clean_url)
        except (json.JSONDecodeError, AttributeError):
            pass

# Override CORS origins to include dynamic ones
CORS_ALLOWED_ORIGINS = DYNAMIC_CORS_ORIGINS + [
    'http://localhost:3000',
    'http://localhost:5173',
    'http://localhost:8000',
    'https://localhost:3000',
    'https://localhost:5173',
    'https://localhost:8000',
]

# âœ… CSRF COMPLETELY DISABLED - NO MORE DUPLICATE SETTINGS

# Session security settings - make permissive
SESSION_COOKIE_SECURE = False
SESSION_COOKIE_HTTPONLY = False
SESSION_COOKIE_SAMESITE = None
SESSION_SAVE_EVERY_REQUEST = True
SESSION_EXPIRE_AT_BROWSER_CLOSE = False

# Disable ALL security headers completely
SECURE_SSL_REDIRECT = False
SECURE_PROXY_SSL_HEADER = None
SECURE_HSTS_SECONDS = 0
SECURE_HSTS_INCLUDE_SUBDOMAINS = False
SECURE_HSTS_PRELOAD = False
SECURE_CONTENT_TYPE_NOSNIFF = False
SECURE_BROWSER_XSS_FILTER = False
SECURE_REFERRER_POLICY = None

# Completely disable X-Frame-Options
X_FRAME_OPTIONS = None

# Additional deployment settings
USE_HTTPS = False
SECURE_REDIRECT_EXEMPT = []  # Empty list - no regex patterns needed

# Force all requests to be treated as secure if needed
if os.getenv('PLATFORM_APPLICATION_NAME'):
    # On Upsun, we might be behind a proxy, but don't enforce security
    SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
    # But still don't redirect or enforce
    SECURE_SSL_REDIRECT = False

# BrightData Integration Settings - Auto-detect domain for Upsun deployment
def get_brightdata_base_url():
    # Manual override via environment variable (highest priority)
    manual_url = os.getenv('BRIGHTDATA_BASE_URL')
    if manual_url:
        return manual_url

    # Auto-detect for Upsun/Platform.sh deployment
    if os.getenv('PLATFORM_APPLICATION_NAME'):
        # Get the default route from Platform.sh environment
        platform_routes = os.getenv('PLATFORM_ROUTES')
        if platform_routes:
            try:
                import json
                routes = json.loads(platform_routes)
                # Find the primary HTTPS route
                for route_url, route_config in routes.items():
                    if route_config.get('primary') and route_url.startswith('https://'):
                        return route_url.rstrip('/')
                # Fallback: use the first HTTPS route
                for route_url in routes.keys():
                    if route_url.startswith('https://'):
                        return route_url.rstrip('/')
            except (json.JSONDecodeError, AttributeError):
                pass

        # Fallback: construct from app name and default Upsun domain
        app_name = os.getenv('PLATFORM_APPLICATION_NAME')
        project_id = os.getenv('PLATFORM_PROJECT')
        environment = os.getenv('PLATFORM_ENVIRONMENT', 'main')
        if app_name and project_id:
            return f"https://{app_name}-{project_id}.{environment}.platformsh.site"

    # Development fallback
    return 'http://localhost:8000'

BRIGHTDATA_BASE_URL = get_brightdata_base_url()
BRIGHTDATA_WEBHOOK_TOKEN = os.getenv('BRIGHTDATA_WEBHOOK_TOKEN', 'your-default-webhook-secret-token-change-this')

# Production/Upsun settings.
if (os.getenv('PLATFORM_APPLICATION_NAME') is not None):
    # Keep DEBUG True for now to avoid issues
    DEBUG = True

    # Static files for production - match Upsun mount path
    STATIC_ROOT = '/app/staticfiles'

    # Secret Key.
    if (os.getenv('PLATFORM_PROJECT_ENTROPY') is not None):
        SECRET_KEY = os.getenv('PLATFORM_PROJECT_ENTROPY')

    # Allow all hosts for deployment
    ALLOWED_HOSTS = ['*']

    # Production database configuration.
    if (os.getenv('PLATFORM_ENVIRONMENT') is not None):
        DATABASES = {
            'default': {
                'ENGINE': 'django.db.backends.postgresql',
                'NAME': os.getenv('DATABASE_PATH'),
                'USER': os.getenv('DATABASE_USERNAME'),
                'PASSWORD': os.getenv('DATABASE_PASSWORD'),
                'HOST': os.getenv('DATABASE_HOST'),
                'PORT': os.getenv('DATABASE_PORT'),
            },
            'sqlite': {
                'ENGINE': 'django.db.backends.sqlite3',
                'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
            }
        }

# Add webhook configuration
WEBHOOK_RATE_LIMIT = os.environ.get('WEBHOOK_RATE_LIMIT', 100)  # requests per minute
WEBHOOK_MAX_TIMESTAMP_AGE = os.environ.get('WEBHOOK_MAX_TIMESTAMP_AGE', 300)  # 5 minutes
WEBHOOK_MAX_EVENTS = os.environ.get('WEBHOOK_MAX_EVENTS', 1000)
WEBHOOK_METRICS_RETENTION = os.environ.get('WEBHOOK_METRICS_RETENTION', 3600)  # 1 hour
WEBHOOK_ERROR_THRESHOLD = os.environ.get('WEBHOOK_ERROR_THRESHOLD', 0.1)  # 10%
WEBHOOK_RESPONSE_TIME_THRESHOLD = os.environ.get('WEBHOOK_RESPONSE_TIME_THRESHOLD', 5.0)  # 5 seconds
WEBHOOK_ENABLE_CERT_PINNING = os.environ.get('WEBHOOK_ENABLE_CERT_PINNING', 'False').lower() == 'true'

# Webhook IP whitelist (comma-separated)
WEBHOOK_ALLOWED_IPS = [ip.strip() for ip in os.environ.get('WEBHOOK_ALLOWED_IPS', '').split(',') if ip.strip()]

# Auto-detect Upsun/Production URLs
def get_webhook_base_url():
    """Auto-detect the correct base URL for webhooks based on environment"""

    # Check for explicit override
    if 'BRIGHTDATA_BASE_URL' in os.environ:
        return os.environ['BRIGHTDATA_BASE_URL']

    # Upsun environment detection
    if 'PLATFORM_ROUTES' in os.environ:
        try:
            import json
            routes = json.loads(os.environ['PLATFORM_ROUTES'])
            # Find the primary route
            for route_url, route_config in routes.items():
                if route_config.get('primary', False):
                    return route_url.rstrip('/')
            # Fallback to first HTTPS route
            for route_url in routes.keys():
                if route_url.startswith('https://'):
                    return route_url.rstrip('/')
        except (json.JSONDecodeError, KeyError):
            pass

    # Platform.sh environment detection
    if 'PLATFORM_APPLICATION_NAME' in os.environ:
        app_name = os.environ.get('PLATFORM_APPLICATION_NAME', 'app')
        branch = os.environ.get('PLATFORM_BRANCH', 'main')
        project_id = os.environ.get('PLATFORM_PROJECT', '')
        if project_id:
            return f"https://{branch}-{project_id}.platformsh.site"

    # Ngrok detection for development
    if 'NGROK_URL' in os.environ:
        return os.environ['NGROK_URL']

    # Railway detection
    if 'RAILWAY_STATIC_URL' in os.environ:
        return f"https://{os.environ['RAILWAY_STATIC_URL']}"

    # Heroku detection
    if 'HEROKU_APP_NAME' in os.environ:
        return f"https://{os.environ['HEROKU_APP_NAME']}.herokuapp.com"

    # Local development fallback
    return 'http://localhost:8000'

BRIGHTDATA_BASE_URL = get_webhook_base_url()

# Ngrok support for local development
NGROK_ENABLED = os.environ.get('NGROK_ENABLED', 'False').lower() == 'true'
NGROK_AUTH_TOKEN = os.environ.get('NGROK_AUTH_TOKEN', '')
NGROK_SUBDOMAIN = os.environ.get('NGROK_SUBDOMAIN', '')
NGROK_REGION = os.environ.get('NGROK_REGION', 'us')  # us, eu, ap, au, sa, jp, in

# Cache configuration for webhook monitoring
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
        'LOCATION': 'default-cache',
        'TIMEOUT': 300,  # 5 minutes default
        'OPTIONS': {
            'MAX_ENTRIES': 1000,
            'CULL_FREQUENCY': 3,
        }
    },
    'webhook_cache': {
        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
        'LOCATION': 'webhook-cache',
        'TIMEOUT': 3600,  # 1 hour default
        'OPTIONS': {
            'MAX_ENTRIES': 10000,
            'CULL_FREQUENCY': 3,
        }
    }
}

# Development-specific webhook settings
if DEBUG:
    # More permissive settings for development
    WEBHOOK_RATE_LIMIT = 1000
    WEBHOOK_MAX_TIMESTAMP_AGE = 600  # 10 minutes
    WEBHOOK_ALLOWED_IPS = []  # Allow all IPs in development

    # Enable ngrok auto-detection
    if NGROK_ENABLED and not BRIGHTDATA_BASE_URL.startswith('https://'):
        try:
            import requests
            response = requests.get('http://localhost:4040/api/tunnels', timeout=2)
            if response.status_code == 200:
                tunnels = response.json().get('tunnels', [])
                for tunnel in tunnels:
                    if tunnel.get('proto') == 'https':
                        BRIGHTDATA_BASE_URL = tunnel['public_url']
                        break
        except:
            pass  # Ngrok not running or not accessible

print(f"Webhook Base URL: {BRIGHTDATA_BASE_URL}")  # For debugging
